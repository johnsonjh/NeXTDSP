/* Mike - set DSP_VERSION to 0 for sound library version - Julius */
#define DSP_VERSION 0
#define DPRINT DSP_VERSION

/*
 *	snddriver_client.c - pseudo-MIG client side for the sound/dsp driver.
 *	1.0 version generated by Lee Boynton and Gregg Kellogg
 *	Copyright 1988-90 NeXT, Inc.
 *
 * New entry points for release 2.0:
 *	snddriver_dsp_reset
 *	snddriver_new_device_port
 *	snddriver_dspcmd_abortdma
 * 	snddriver_set_dsp_buffers_per_soundout_buffer
 *	snddriver_dsp_dma_write
 *	snddriver_dsp_dma_read
 *	snddriver_dsp_read_data
 *	snddriver_dsp_read_messages
 *	snddriver_set_ramp
 *	snddriver_reset_dsp_owner
 *	snddriver_reset_sndin_owner
 *	snddriver_reset_sndout_owner
 *	snddriver_set_sndout_bufsize
 *	snddriver_set_sndout_bufcount
 *	snddriver_stream_ndma
 *
 * Modification history
 * 03/10/90/jos - Tested commented system panic by moving stream_options 
 *		  setting before record/write in 
 *		  snddriver_start_{reading,writing} instead of after.
 *		  This caused a panic as advertised, so I put them back.
 *		- added setting of stream options to 
 *		  case SNDDRIVER_STREAM_DSP_TO_SNDOUT_{22,44} in stream_setup.
 *		  See comment there. This was the new Ensemble delay bug.  
 * 		  The default in 2.0 will thus be 8 DSP buffers per SO buffer.
 *		- Added static int DSPBuffersPerSoundoutBuffer = 8;
 * 		- Added snddriver_set_dsp_buffers_per_soundout_buffer().
 *		  It seems we should add a second buf_size argument to the
 *		  the stream_parms struct which would only be used by the
 *		  DSP->SoundOut link (and by the SoundIn->DSP link when we 
 *		  add support for that).  Would this be safe to add?
 * 		- Flushed SNDDRIVER_DSP_PROTO_SOUNDDATA bit which was being used
 *		  to bypass DMA.
 *		- added snddriver_dspcmd_chandata() for specifying DSP side
 *		  of DMA transfer, then flushed it, deciding that the user
 *		  should set that up privately with the DSP. The driver
 *		  should only read and write the interface...  it should
 *		  not depend on a DSP setup protocol like AP/MK mons have.
 * 		  Currently, dma_{read,write} do their own chan data 
 *		  internally. DSP-initiated transfers must use chandata?
 * 04/03/90/mmm&mm - added kern_return_t snddriver_dsp_reset
 * 04/08/90/jos - incorporated latest dma_{read,write} from
 *		  ~mchristo/dma_test/dma_test.c.
 * 04/08/90/jos - added snddriver_new_device_port().  See VERSION_1.
 * 04/09/90/mtm - comment out various unused functions and variables.
 * 04/11/90/mtm - committed to snddriver_dspcmd_abortdma as a 2.0 function.
 * 04/13/90/mtm - re-disabled dma when streaming through dsp.
 * 04/17/90/jos - made dma enable a function of DMA_FIXED definition.
 * 04/17/90/jos - made snddriver_dspcmd_abortdma a fn of VERSION_1 definition
 * 04/17/90/jos - changed dsp_dma_{read,write} to libdsp_dma_{read,write}
 * 04/17/90/jos - made dsp_dma_{read,write} versions free of DSP protocol
 * 05/04/90/jos - *** FIXME *** QUESTION *** Does SI_CHAN refer to the
 *		  microphone input or to the DSP sound-in channel or both?!?!?
 * 5/7/90/m.c.	- Updated dsp_dma_write and dsp_dma_read to set up chandata
 *		  so user is not required to do a sounddriver_stream_setup().
 *		  DSP buffer size must be the same as the transfer size.
 * 05/22/90/jos - Changed STREAM_TO_DSP case to use p:0 write => DSP-initiated
 * 06/05/90/jos - Added DMA_STREAM_TO_DSP and DMA_STREAM_FROM_DSP cases
 * 		  for 1.0 compatibility.  The first is needed to get 
 *		  DSP-initiated DMA to happen.  A new stream type is defined
 * 		  because the DSP code necessary to support a STREAM_TO_DSP
 *		  is different when DMA is actually used. A second "FROM_DSP"
 *		  stream type was defined purely for symmetry. There is no
 * 		  difference in that direction because DMA was working in 1.0.
 * 06/07/90/jos - Flushed chandata args from snddriver_dsp_dma_{read,write}.
 * 06/07/90/jos - Moved *_PROTO_C_DMA and *_PROTO_S_DMA protocol bit defs to 
 *		  snddriver.h. They are needed when setting the protocol.
 * 06/14/90/mtm - rename static free_steam_params() to free_stream_params().
 *		  Use calloc in put_stream_params().
 * 06/14/90/mtm - change snd_send_stream_msg() to use msg_rpc().
 * 06/18/90/jos - change snddriver_dsp{cmd_req_condition,_set_flags,
 * 		  _host_cmd, _write, _reset, _boot}() to use msg_rpc().
 * 07/09/90/jos - changed sndmsg_dsp_data() to pass 3-byte DSP data type.
 * 07/09/90/jos - changed sndmsg_dsp_data() to take type arg (read|write).
 * 07/14/90/jos - added snddriver_dsp_read_messages()
 *		  changed snddriver_dsp_read() to "do the right thing"
 *		  whatever the dsp protocol.
 * 07/17/90/mtm - In snddriver_stream_setup(), set SND_DSP_PROTO_HIGH in
 *		  SNDDRIVER_DMA_STREAM_THROUGH_DSP_TO_SNDOUT_44 case.
 * 07/17/90/mtm	- Fix chandata setup for above case.
 * 07/18/90/mtm - Made all static message const.
 * 08/05/90/jos - Fixed infinite port_allocate bug, snddriver_dsp_read_messages
 *		  Added protection against crossing page boundary in dma_write
 *		  Fixed dma_read in multi-page case.
 * 08/13/90/mtm	- Cast owner port type messages to msg_header_t.
 * 09/18/90/mtm	- Add snddriver_reset_{dsp,sndin,sndout}_owner() (bug #9400).
 * 09/24/90/mtm - Make all messages rpc's with timeouts (bug #4673).
 * 09/26/90/mtm - Add snddriver_set_sndout_buf{size,count} and
 *		  snddriver_stream_ndma, removed
 *		  snddriver_set_dsp_buffers_per_soundout_buffer()
 *		  (bug #7727 and 7728).

 To do:
 
 Use new DSP interrupt to break all deadlocks when reading and writing.
 Support SNDIN to/through DSP link.
 Remove snddriver_set_sndout_{bufsize,bufcount}, replace with generic
  snddriver_set_stream_param(stream,param).
 Replace snddriver_stream_setup() with var_args function switched on configuration.

 */

#import <nextdev/snd_msgs.h>

#if DSP_VERSION
#import "snddriver.h"
#else
#import "sounddriver.h"
#endif

#ifndef MIN
#define MIN(x,y) ((x)<(y)?(x):(y))
#endif MIN

/*
 * local support
 */

static int timeout = 10000;	/*** FIXME: Need outside control of this */
static int msg_rpc_options = (SEND_TIMEOUT|RCV_TIMEOUT);
static int dsp_protocol = 0;	/* saved by snddriver_dsp_proto() */

/* static int msg_rpc_options = MSG_OPTION_NONE; // when timeout set to 0 */

static int so_buf_size = 0;	/* in bytes */
static int so_buf_count = 4;

/*
 * Kludge to remember stream setup data for write/read requests
 * entry 0 is for soundout, 1 for soundin, 2 for dspout, and 3 for dspin
 */
 
 typedef struct {
    port_t port;
    int	low_water, high_water, buf_size, buf_width;
 } stream_parms;

 static stream_parms *stream_table = 0;
 static stream_table_max = 0;

/*** FIXME: Need to be able to call this from user level.
	Especially need to be able to change sample width. ***/

static void put_stream_parms(port_t stream_port, int lo, int hi, int size,
							int width)
{
    int i;
    for (i=0; i<stream_table_max; i++)
	if (!stream_table[i].port)
	    break;
    if (i == stream_table_max) {
	stream_parms *old_table = stream_table;
	int j, old_max = stream_table_max;
	stream_table_max = stream_table_max? 2*stream_table_max : 4;
	stream_table = (stream_parms *)
				calloc(1, stream_table_max*sizeof(stream_parms));
	if (old_table) {
	    for (j=0; j<old_max; j++)
		stream_table[j] = old_table[j];
	    free(old_table);
	}
    }
    stream_table[i].port = stream_port;
    stream_table[i].low_water = lo;
    stream_table[i].high_water = hi;
    stream_table[i].buf_size = size;
    stream_table[i].buf_width = width;
}

static int get_stream_parms(port_t stream_port, int *lo,
				 int *hi, int *size, int *width)
{
    int i;
    for (i=0; i<stream_table_max; i++)
	if (stream_table[i].port == stream_port) {
	    *lo = stream_table[i].low_water;
	    *hi = stream_table[i].high_water;
	    *size = stream_table[i].buf_size;
	    *width = stream_table[i].buf_width;
	    return 0;
	}
    return -1;
}

static void free_stream_parms(port_t stream_port)
{
    int i;
    for (i=0; i<stream_table_max; i++)
	if (stream_table[i].port == stream_port) {
	    stream_table[i].port = PORT_NULL;
	    return;
	}
}

static kern_return_t error_ret(snd_illegal_msg_t *msg, int from_msgid)
{
	switch (msg->header.msg_id) {
	case SND_MSG_ILLEGAL_MSG: {
		if (msg->ill_msgid != from_msgid)
			return KERN_FAILURE;
		if (msg->ill_error == SND_NO_ERROR)
			return KERN_FAILURE;
		return msg->ill_error;
	}
	default:
		return KERN_FAILURE;
	}
}

static kern_return_t normal_ret(snd_illegal_msg_t *msg, int from_msgid)
{
	switch (msg->header.msg_id) {
	case SND_MSG_ILLEGAL_MSG: {
		if (msg->ill_msgid != from_msgid)
			return KERN_FAILURE;
		if (msg->ill_error == SND_NO_ERROR)
			return KERN_SUCCESS;
		return msg->ill_error;
	}
	default:
		return KERN_FAILURE;
	}
}

static kern_return_t snd_return_code(snd_illegal_msg_t *msg)
{
/*    return (msg->msg_id != SND_MSG_ILLEGAL_MSG) ||
	      (((snd_illegal_msg_t *)msg)->ill_error != SND_NO_ERROR); */
	switch (msg->header.msg_id) {
	case SND_MSG_ILLEGAL_MSG: {
		if (msg->ill_error == SND_NO_ERROR)
			return KERN_SUCCESS;
		return msg->ill_error;
	}
	default:
		return KERN_FAILURE;
	}
}

/*
 * Composite message sent to dsp command queue.
 * Message will consist of some combination of:
 *	condition	mask and set of register values
 *	data		1, 2, or 4 byte data
 *	host command
 *	host flags	only ICR_HF0 or ICRHF1
 *	ret message	message to be sent (to reply port)
 */

/*
 * Returns a message header of initial size size used to contain
 * a set of requests to dsp command port.
 */
static msg_header_t *sndmsg_dspcmd_msg (
	port_t	cmd_port,		// valid dsp command port
	port_t	reply_port,		// where to send reply message(s)
	int	priority,		// DSP_MSG_{LOW,MED,HIGH}
	int	atomic)			// message may not be preempted
{
	snd_dspcmd_msg_t *m = (snd_dspcmd_msg_t *)malloc(MSG_SIZE_MAX);
	static const snd_dspcmd_msg_t M = {
		{
			/* no name */		0,
			/* msg_simple */	TRUE,
			/* msg_size */		sizeof(snd_dspcmd_msg_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_DSP_MSG
		},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		2,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		}
	};

	*m = M;
	m->header.msg_remote_port = cmd_port;
	m->header.msg_local_port = reply_port;
	m->pri = priority;
	m->atomic = atomic;
	return ((msg_header_t *)m);
}

/*
 * Add a condition to the message.
 */
static msg_header_t *sndmsg_dsp_condition (
	msg_header_t	*msg,		// message frame to add request to
	u_int		mask,		// mask of flags to inspect
	u_int		flags,		// set of flags that must be on
	port_t		reply_port)	// port to send device regs to
{
	snd_dsp_condition_t *m =
		(snd_dsp_condition_t *)(((int)msg)+msg->msg_size);
	static const snd_dsp_condition_t M = {
		{{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		SND_DSP_MT_CONDITION},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		2,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0,0,
		{
			/* msg_type_name = */		MSG_TYPE_PORT,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0
	};
			
	if (msg->msg_size + sizeof(*m) >= MSG_SIZE_MAX)
		return (msg_header_t *)SEND_MSG_TOO_LARGE;

	/*
	 * Add this message component to the message.
	 */
	*m = M;
	m->mask = mask;
	m->flags = flags;
	m->reply_port = reply_port;

	/*
	 * No longer a simple message (passing a port).
	 */
	msg->msg_simple = FALSE;
	msg->msg_size += sizeof(*m);
	return(msg);
}

#if 0
THIS IS KNOWN TO BREAK snddriver_dsp_boot()!  See FIXME below.
/*
 * This one is the union of the next two.
 * Add transmit data request to dsp command message.
 */
static msg_header_t *sndmsg_dsp_data (
	msg_header_t	*msg,		// message frame to add request to
	int		type,		// One of SND_DSP_MT_{DATA,RDATA}
	pointer_t	data,		// data to play
	int		eltsize,	// 1, 2, or 4 byte data
	int		nelts)		// number of elements of data to send
{
	int msize, dsize;
	snd_dsp_data_t *m =
		(snd_dsp_data_t *)(((int)msg)+msg->msg_size);
	static const snd_dsp_data_t M = {
		{{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		 0 /* type */},
		{
			{
				/* msg_type_name = */		0,
				/* msg_type_size = */		0,
				/* msg_type_number = */		0,
				/* msg_type_inline = */		TRUE,
				/* msg_type_longform = */	TRUE,
				/* msg_type_deallocate = */	FALSE,
			},
			/* msg_type_long_name = */	MSG_TYPE_INTEGER_32,
			/* msg_type_long_size = */	0,
			/* msg_type_long_number = */	0,
		},
		0,
	};
			
	if (eltsize < 1 || eltsize > 4)
		eltsize = 1;
	dsize = eltsize * nelts;

	/*
	 * Add this message component to the message.
	 */
	*m = M;

	if (type == SND_DSP_MT_RDATA) {
		dsize = 0;
	}
	else if (msize >= MSG_SIZE_MAX) {
		/*
		 * Too big to be sent inline, construct out-of-line data
		 * message.
		 */
		m->dataType.msg_type_header.msg_type_inline = FALSE;
		*(pointer_t *)&m->data = data;
		dsize = 0;
		msg->msg_simple = FALSE;
	} else {
		/*
		 * Send data inline.
		 */
		memmove((char *)&m->data, (char *)data, dsize);
		//bcopy((char *)data, (char *)&m->data, dsize);
	}
	if (dsize > 0)
		msize = sizeof(*m) - sizeof(m->data) + dsize;
	else
		msize = sizeof(*m);


	m->dataType.msg_type_long_number = nelts;
	m->dataType.msg_type_long_size = eltsize*8;
	m->msgtype.type = type; /*** FIXME: This is the wrong place! ***/

	/*
	 * Message can't be a simple type anymore.
	 */
	msg->msg_size += msize;
	return(msg);
}
#endif

/*
 * Add read-data request to dsp command message.
 */
static msg_header_t *sndmsg_dsp_read_data (
	msg_header_t	*msg,		// message frame to add request to
	int		eltsize,	// 1, 2, 3, or 4 byte data
	int		nelts)		// number of elements of data to read
{
	snd_dsp_data_t *m = (snd_dsp_data_t *)(((int)msg)+msg->msg_size);
	static const snd_dsp_data_t M = {
		{{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		 /* M.msgtype.type */ SND_DSP_MT_RDATA},
	        {
			{
				/* msg_type_name = */		0,
				/* msg_type_size = */		0,
				/* msg_type_number = */		0,
				/* msg_type_inline = */		TRUE,
				/* msg_type_longform = */	TRUE,
				/* msg_type_deallocate = */	FALSE,
			},
			/* msg_type_long_name = */	MSG_TYPE_INTEGER_32,
			/* msg_type_long_size = */	0,
			/* msg_type_long_number = */	0,
		},
		0,
	};
			
	if (eltsize < 1 || eltsize > 4)
		eltsize = 1;

	/*
	 * Add this message component to the message.
	 */
	*m = M;

#if 0
	m->dataType.msg_type_long_number = nelts;
	m->dataType.msg_type_long_size = eltsize*8;
#else
	m->dataType.msg_type_long_number = 4/eltsize;	/* To make it come out
							   to 32-bits */
	m->dataType.msg_type_long_size = eltsize*8;	/* So driver knows data
							   size */
	m->data = nelts * eltsize;			/* How many bytes to 
							   read */
#endif

	/*
	 * Message can't be a simple type anymore.
	 */
	msg->msg_size += sizeof(*m);
	return(msg);
}

/*
 * Add transmit data request to dsp command message.
 */
static msg_header_t *sndmsg_dsp_write_data (
	msg_header_t	*msg,		// message frame to add request to
	pointer_t	data,		// data to play
	int		eltsize,	// 1, 2, 3, or 4 byte data
	int		nelts)		// number of elements of data to send
{
	int msize, dsize;
	snd_dsp_data_t *m =
		(snd_dsp_data_t *)(((int)msg)+msg->msg_size);
	static const snd_dsp_data_t M = {
		{{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		 /* M.msgtype.type */ SND_DSP_MT_DATA},
	        {
			{
				/* msg_type_name = */		0,
				/* msg_type_size = */		0,
				/* msg_type_number = */		0,
				/* msg_type_inline = */		TRUE,
				/* msg_type_longform = */	TRUE,
				/* msg_type_deallocate = */	FALSE,
			},
			/* msg_type_long_name = */	MSG_TYPE_INTEGER_32,
			/* msg_type_long_size = */	0,
			/* msg_type_long_number = */	0,
		},
		0,
	};
			
	if (eltsize < 1 || eltsize > 4)
		eltsize = 1;
	dsize = eltsize * nelts;

	/*
	 * Add this message component to the message.
	 */
	*m = M;

	if (sizeof(*m)+dsize >= MSG_SIZE_MAX) {
		/*
		 * Too big to be sent inline, construct out-of-line data
		 * message.
		 */
		m->dataType.msg_type_header.msg_type_inline = FALSE;
		*(pointer_t *)&m->data = data;
		msize = sizeof(*m);
		msg->msg_simple = FALSE;
	} else {
		/*
		 * Send data inline.
		 */
		memmove((char *)&m->data, (char *)data, dsize);
		/* bcopy((char *)data, (char *)&m->data, dsize); */
		msize = sizeof(*m) - sizeof(m->data) + dsize;
	}

	m->dataType.msg_type_long_number = nelts;
	m->dataType.msg_type_long_size = eltsize*8;

	/*
	 * Message can't be a simple type anymore.
	 */
	msg->msg_size += msize;
	return(msg);
}

/*
 * Add a host command to the message.
 */
static msg_header_t *sndmsg_dsp_host_command (
	msg_header_t	*msg,		// message frame to add request to
	u_int		host_command)	// host command to execute
{
	snd_dsp_host_command_t *m =
		(snd_dsp_host_command_t *)(((int)msg)+msg->msg_size);
	static const snd_dsp_host_command_t M = {
		{{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		SND_DSP_MT_HOST_COMMAND},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		}
	};
			
	if (msg->msg_size + sizeof(*m) >= MSG_SIZE_MAX)
		return (msg_header_t *)SEND_MSG_TOO_LARGE;

	/*
	 * Add this message component to the message.
	 */
	*m = M;
	m->hc = host_command;

	msg->msg_size += sizeof(*m);
	return(msg);
}

/*
 * Add a host flag to the message.
 */
static msg_header_t *sndmsg_dsp_host_flag (
	msg_header_t	*msg,		// message frame to add request to
	u_int		mask,		// mask of flags to inspect
	u_int		flags)		// set of flags that must be on
{
	snd_dsp_host_flag_t *m =
		(snd_dsp_host_flag_t *)(((int)msg)+msg->msg_size);
	static const snd_dsp_host_flag_t M = {
		{{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		SND_DSP_MT_HOST_FLAG},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		2,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		}
	};
			
	if (msg->msg_size + sizeof(*m) >= MSG_SIZE_MAX)
		return (msg_header_t *)SEND_MSG_TOO_LARGE;

	/*
	 * Add this message component to the message.
	 */
	*m = M;
	m->mask = mask;
	m->flags = flags;

	msg->msg_size += sizeof(*m);
	return(msg);
}

/*
 * Add a DSP reset message.
 */
static msg_header_t *sndmsg_dspreset (
	msg_header_t	*msg)		// message frame to add request to
{
	snd_dsp_reset_t *m =
		(snd_dsp_reset_t *)(((int)msg)+msg->msg_size);
	static const snd_dsp_reset_t M = {
		{{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		SND_DSP_MT_RESET}
	};
			
	if (msg->msg_size + sizeof(*m) >= MSG_SIZE_MAX)
		return (msg_header_t *)SEND_MSG_TOO_LARGE;

	/*
	 * Add this message component to the message.
	 */
	*m = M;

	msg->msg_size += sizeof(*m);
	return(msg);
}


/*
 * Add number of dma descriptors to message.
 * New for 2.0.
 */
static msg_header_t *snd_stream_ndma (
	msg_header_t	*msg,		// message frame to add request to
	int		ndma)		// number of dma descs in stream
{
	snd_stream_ndma_t *m =
		(snd_stream_ndma_t *)(((int)msg)+msg->msg_size);
	static const snd_stream_ndma_t M = {
		{{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		SND_MT_NDMA},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0,
	};
			
	if (msg->msg_size + sizeof(*m) >= MSG_SIZE_MAX)
		return (msg_header_t *)SEND_MSG_TOO_LARGE;

	/*
	 * Add this message component to the message.
	 */
	*m = M;
	m->ndma = ndma;

	msg->msg_size += sizeof(*m);
	return(msg);
}

static msg_header_t *snd_stream_msg (
	port_t	stream_port,		// valid stream port
	port_t	reply_port,		// task port or other
	int	data_tag)		// tag associated with request
{
	snd_stream_msg_t *m = (snd_stream_msg_t *)malloc(MSG_SIZE_MAX);
	static const snd_stream_msg_t M = {
		{
			/* no name */		0,
			/* msg_simple */	TRUE,
			/* msg_size */		sizeof(snd_stream_msg_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_STREAM_MSG
		},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		}
	};

	*m = M;
	m->header.msg_remote_port = stream_port;
	m->header.msg_local_port = reply_port;
	m->data_tag = data_tag;
	return ((msg_header_t *)m);
}

static msg_header_t *snd_stream_play_data (
	msg_header_t	*msg,		// message frame to add request to
	pointer_t	data,		// data to play
	boolean_t	started_msg,	// want's a message when started
	boolean_t	completed_msg,	// want's a message when completed
	boolean_t	aborted_msg,	// want's a message when aborted
	boolean_t	paused_msg,	// want's a message when paused
	boolean_t	resumed_msg,	// want's a message when resumed
	boolean_t	underflow_msg,	// want's a message on underflow
	boolean_t	preempt,	// play preemptively
	boolean_t	deallocate,	// deallocate data when sent?
	port_t		reg_port,	// port for region events
	int		nbytes)		// number of bytes of data to send
{
	snd_stream_play_data_t *m =
		(snd_stream_play_data_t *)(((int)msg)+msg->msg_size);
	static const snd_stream_play_data_t M = {
		{{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		SND_MT_PLAY_DATA},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0,
		{
			/* msg_type_name = */		MSG_TYPE_PORT,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0,
		{
			{
				/* msg_type_name = */		0,
				/* msg_type_size = */		0,
				/* msg_type_number = */		0,
				/* msg_type_inline = */		FALSE,
				/* msg_type_longform = */	TRUE,
				/* msg_type_deallocate = */	FALSE,
			},
			/* msg_type_long_name = */	MSG_TYPE_INTEGER_8,
			/* msg_type_long_size = */	8,
			/* msg_type_long_number = */	0,
		},
		0,
	};
			
	if (msg->msg_size + sizeof(*m) >= MSG_SIZE_MAX)
		return (msg_header_t *)SEND_MSG_TOO_LARGE;

	/*
	 * Add this message component to the message.
	 */
	*m = M;
	m->options =   (started_msg?SND_DM_STARTED_MSG:0)
		     | (completed_msg?SND_DM_COMPLETED_MSG:0)
		     | (aborted_msg?SND_DM_ABORTED_MSG:0)
		     | (paused_msg?SND_DM_PAUSED_MSG:0)
		     | (resumed_msg?SND_DM_RESUMED_MSG:0)
		     | (underflow_msg?SND_DM_OVERFLOW_MSG:0)
		     | (preempt?SND_DM_PREEMPT:0);
	m->data = data;
	m->reg_port = reg_port;
	m->dataType.msg_type_long_number = nbytes;
	if (deallocate)
		m->dataType.msg_type_header.msg_type_deallocate = TRUE;

	/*
	 * Message can't be a simple type anymore.
	 */
	msg->msg_simple = FALSE;
	msg->msg_size += sizeof(*m);
	return(msg);
}

static msg_header_t *snd_stream_record_data (
	msg_header_t	*msg,		// message frame to add request to
	boolean_t	started_msg,	// want's a message when started
	boolean_t	completed_msg,	// want's a message when completed
	boolean_t	aborted_msg,	// want's a message when aborted
	boolean_t	paused_msg,	// want's a message when paused
	boolean_t	resumed_msg,	// want's a message when resumed
	boolean_t	overflow_msg,	// want's a message on overflow
	int		nbytes,		// number of bytes of data to record
	port_t		reg_port,	// port for region events
	char		*filename)	// file for backing store (or null)
{
	snd_stream_record_data_t *m =
		(snd_stream_record_data_t *)(((int)msg)+msg->msg_size);
	static const snd_stream_record_data_t M = {
		{{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		SND_MT_RECORD_DATA},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		2,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0,
		0,
		{
			/* msg_type_name = */		MSG_TYPE_PORT,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0,
		{
			/* msg_type_name = */		MSG_TYPE_CHAR,
			/* msg_type_size = */		8,
			/* msg_type_number = */		0,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		}
	};
			
	if (msg->msg_size + sizeof(*m) >= MSG_SIZE_MAX)
		return (msg_header_t *)SEND_MSG_TOO_LARGE;

	/*
	 * Add this message component to the message.
	 */
	*m = M;
	m->options =   (started_msg?SND_DM_STARTED_MSG:0)
		     | (completed_msg?SND_DM_COMPLETED_MSG:0)
		     | (aborted_msg?SND_DM_ABORTED_MSG:0)
		     | (paused_msg?SND_DM_PAUSED_MSG:0)
		     | (resumed_msg?SND_DM_RESUMED_MSG:0)
		     | (overflow_msg?SND_DM_OVERFLOW_MSG:0);
	m->nbytes = nbytes;
	m->reg_port = reg_port;
	if (filename) {
		strcpy((char *)(m+1), filename);
		m->filenameType.msg_type_number = strlen(filename+1);
	} else
		m->filenameType.msg_type_number = 0;

	msg->msg_size += sizeof(*m);
	msg->msg_simple = FALSE;
	return(msg);
}

static msg_header_t *snd_stream_control (
	msg_header_t	*msg,		// message frame to add request to
	int		snd_control)	// await/abort/pause/resume
{
	snd_stream_control_t *m =
		(snd_stream_control_t *)(((int)msg)+msg->msg_size);
	static const snd_stream_control_t M = {
		{{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		SND_MT_CONTROL},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0,
	};
			
	if (msg->msg_size + sizeof(*m) >= MSG_SIZE_MAX)
		return (msg_header_t *)SEND_MSG_TOO_LARGE;

	/*
	 * Add this message component to the message.
	 */
	*m = M;
	m->snd_control = snd_control;

	msg->msg_size += sizeof(*m);
	return(msg);
}

static msg_header_t *snd_stream_options (
	msg_header_t	*msg,		// message frame to add request to
	int		high_water,
	int		low_water,
	int		dma_size)
{
	snd_stream_options_t *m =
		(snd_stream_options_t *)(((int)msg)+msg->msg_size);
	static const snd_stream_options_t M = {
		{{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		SND_MT_OPTIONS},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		3,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
	};
			
	if (msg->msg_size + sizeof(*m) >= MSG_SIZE_MAX)
		return (msg_header_t *)SEND_MSG_TOO_LARGE;

	/*
	 * Add this message component to the message.
	 */
	*m = M;
	m->high_water = high_water;
	m->low_water = low_water;
	m->dma_size = dma_size;

	msg->msg_size += sizeof(*m);
	return(msg);
}

static int snd_send_stream_msg(msg_header_t *msg)
{
    int err = msg_rpc(msg, msg_rpc_options, MSG_SIZE_MAX, timeout, timeout);
    if (err != KERN_SUCCESS) return err;
    if ( (msg->msg_id != SND_MSG_ILLEGAL_MSG) ||
	 	(((snd_illegal_msg_t *)msg)->ill_error != SND_NO_ERROR) ) {
	err = ((snd_illegal_msg_t *)msg)->ill_error;
	msg_receive(msg, RCV_TIMEOUT, 1); // kernel bug : extra reply
	return err;
    }
    return KERN_SUCCESS;
}

/*
 *********************** Exports ***********************
 */

/*
 * Generic setup functions
 */
kern_return_t snddriver_get_device_parms (
	port_t		device_port,		// valid device port
	boolean_t	*speaker,		// returned speaker enable	
	boolean_t	*lowpass,		// returned lowpass filter en.
	boolean_t	*zerofill)		// zero fill doubled samples?
{
	register int r;
	union {
		snd_get_parms_t		g_parms;
		snd_ret_parms_t		r_parms;
		snd_illegal_msg_t	r_ill;
		msg_header_t		header;
	} msg;

	static const snd_get_parms_t M = {
		/* no name */		0,
		/* msg_simple */	TRUE,
		/* msg_size */		sizeof(snd_get_parms_t),
		/* msg_type */		MSG_TYPE_NORMAL,
		/* msg_remote_port */	0,
		/* msg_reply_port */	0,
		/* msg_id */		SND_MSG_GET_PARMS
	};

	msg.g_parms = M;
	msg.header.msg_remote_port = device_port;
	msg.header.msg_local_port = thread_reply();
	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r != KERN_SUCCESS)
		return r;
	if (msg.header.msg_id != SND_MSG_RET_PARMS)
		return error_ret(&msg.r_ill, SND_MSG_GET_PARMS);

	*speaker = msg.r_parms.parms&SND_PARM_SPEAKER;
	*lowpass = msg.r_parms.parms&SND_PARM_LOWPASS;
	*zerofill = msg.r_parms.parms&SND_PARM_ZEROFILL;
	return r;
}

kern_return_t snddriver_set_device_parms (
	port_t		device_port,		// valid device port
	boolean_t	speaker,		// enable speaker	
	boolean_t	lowpass,		// enable lowpass filter
	boolean_t	zerofill)		// zero fill doubled samples
{
	register int r;
	union {
		snd_set_parms_t		s_parms;
		snd_illegal_msg_t	r_ill;
		msg_header_t		header;
	} msg;

	static const snd_set_parms_t M = {
		{
			/* no name */		0,
			/* msg_simple */	TRUE,
			/* msg_size */		sizeof(snd_set_parms_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_SET_PARMS
		},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		}
	};

	msg.s_parms = M;
	msg.header.msg_remote_port = device_port;
	msg.header.msg_local_port = thread_reply();

	msg.s_parms.parms =   (speaker ? SND_PARM_SPEAKER : 0)
		   | (lowpass ? SND_PARM_LOWPASS : 0)
		   | (zerofill ? SND_PARM_ZEROFILL : 0);

	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r != KERN_SUCCESS)
		return r;
	return normal_ret(&msg.r_ill, SND_MSG_SET_PARMS);
}

kern_return_t snddriver_set_ramp (
	port_t		device_port,		// valid device port
	int		rampflags)		// Flags for setting ramp
{
	register int r;
	union {
		snd_set_parms_t		s_parms;
		snd_illegal_msg_t	r_ill;
		msg_header_t		header;
	} msg;

	static const snd_set_parms_t M = {
		{
			/* no name */		0,
			/* msg_simple */	TRUE,
			/* msg_size */		sizeof(snd_set_parms_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_SET_RAMP
		},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		}
	};

	msg.s_parms = M;
	msg.header.msg_remote_port = device_port;
	msg.header.msg_local_port = thread_reply();

	msg.s_parms.parms =  rampflags;

	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r != KERN_SUCCESS)
		return r;
	return normal_ret(&msg.r_ill, SND_MSG_SET_RAMP);
}

kern_return_t snddriver_get_volume (
	port_t		device_port,		// valid device port
	int		*left_chan,		// returned volume
	int		*right_chan)		// returned volume
{
	register int r;
	union {
		snd_get_volume_t	g_volume;
		snd_ret_volume_t	r_volume;
		snd_illegal_msg_t	r_ill;
		msg_header_t		header;
	} msg;

	static const snd_get_volume_t M = {
		/* no name */		0,
		/* msg_simple */	TRUE,
		/* msg_size */		sizeof(snd_get_volume_t),
		/* msg_type */		MSG_TYPE_NORMAL,
		/* msg_remote_port */	0,
		/* msg_reply_port */	0,
		/* msg_id */		SND_MSG_GET_VOLUME
	};

	msg.g_volume = M;
	msg.header.msg_remote_port = device_port;
	msg.header.msg_local_port = thread_reply();
	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r != KERN_SUCCESS)
		return r;
	if (msg.header.msg_id != SND_MSG_RET_VOLUME)
		return error_ret(&msg.r_ill, SND_MSG_GET_VOLUME);

	*left_chan = (msg.r_volume.volume&SND_VOLUME_LCHAN_MASK)>>
		SND_VOLUME_LCHAN_SHIFT;
	*right_chan = (msg.r_volume.volume&SND_VOLUME_RCHAN_MASK)>>
		SND_VOLUME_RCHAN_SHIFT;
	return r;
}

kern_return_t snddriver_set_volume (
	port_t		device_port,		// valid device port
	int		left_chan,		// volume on left channel	
	int		right_chan)		// volume on right channel	
{
	register int r;
	union {
		snd_set_volume_t	s_volume;
		snd_illegal_msg_t	r_ill;
		msg_header_t		header;
	} msg;
	static const snd_set_volume_t M = {
		{
			/* no name */		0,
			/* msg_simple */	TRUE,
			/* msg_size */		sizeof(snd_set_volume_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_SET_VOLUME
		},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		}
	};

	msg.s_volume = M;
	msg.header.msg_remote_port = device_port;
	msg.header.msg_local_port = thread_reply();

	msg.s_volume.volume =   (left_chan<<SND_VOLUME_LCHAN_SHIFT)
			  | (right_chan<<SND_VOLUME_RCHAN_SHIFT);

	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r != KERN_SUCCESS)
		return r;
	return normal_ret(&msg.r_ill, SND_MSG_SET_VOLUME);
}

static kern_return_t snddriver_set_owner (
	port_t		device_port,
	port_t		owner_port,
	port_t		*neg_port,
	int		msg_id)
{
	register int r;
	union {
		snd_illegal_msg_t	r_ill;
		snd_set_owner_t		s_own;
		msg_header_t		header;
	} msg;
	static const snd_set_owner_t M = {
		{
			/* no name */		0,
			/* msg_simple */	FALSE,
			/* msg_size */		sizeof(snd_set_owner_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		0
		},
		{
			/* msg_type_name = */		MSG_TYPE_PORT,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0,
		{
			/* msg_type_name = */		MSG_TYPE_PORT,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0
	};

	msg.s_own = M;
	msg.header.msg_id = msg_id;
	msg.header.msg_remote_port = device_port;
	msg.header.msg_local_port = thread_reply();
	msg.s_own.owner = owner_port;
	msg.s_own.negotiation = *neg_port;

	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r == KERN_SUCCESS)
		r = normal_ret(&msg.r_ill, msg_id);
	if (r != KERN_SUCCESS)
		*neg_port = msg.r_ill.header.msg_remote_port;
	return r;
}

/*
 * Tells the driver who the owner of the DSP device is,
 * for returning unsolicited messages and allocating resources.
 */
kern_return_t snddriver_set_dsp_owner_port (
	port_t		device_port,	// valid device port
	port_t		owner_port,	// dsp owner port
	port_t		*neg_port)	// dsp negotiation port
{
	return snddriver_set_owner(device_port, owner_port, neg_port,
				   SND_MSG_SET_DSPOWNER);
}

/*
 * Tells the driver who the owner of the sound in device is.
 */
kern_return_t snddriver_set_sndin_owner_port (
	port_t		device_port,	// valid device port
	port_t		owner_port,	// sound in owner port
	port_t		*neg_port)	// sound in negotiation port
{
	return snddriver_set_owner(device_port, owner_port, neg_port,
				   SND_MSG_SET_SNDINOWNER);
}

/*
 * Tells the driver who the owner of sound out device is.
 */
kern_return_t snddriver_set_sndout_owner_port (
	port_t		device_port,	// valid device port
	port_t		owner_port,	// sound out owner port
	port_t		*neg_port)	// sound out negotiation port
{
	return snddriver_set_owner(device_port, owner_port, neg_port,
				   SND_MSG_SET_SNDOUTOWNER);
}

kern_return_t snddriver_get_dsp_cmd_port (
	port_t		device_port,		// valid device port
	port_t		owner_port,		// valid owner port
	port_t		*cmd_port)		// returned command port
{
	int r;
	union {
		snd_get_dsp_cmd_port_t	g_cmd;
		snd_ret_port_t		r_cmd;
		snd_illegal_msg_t	r_ill;
		msg_header_t		header;
	} msg;
	static const snd_get_dsp_cmd_port_t M = {
		{
			/* no name */		0,
			/* msg_simple */	FALSE,
			/* msg_size */		sizeof(snd_get_dsp_cmd_port_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_GET_DSP_CMD_PORT
		},
		{
			/* msg_type_name = */		MSG_TYPE_PORT,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0
	};

	msg.g_cmd = M;
	msg.header.msg_remote_port = device_port;
	msg.header.msg_local_port = thread_reply();
	msg.g_cmd.owner = owner_port;

	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r != KERN_SUCCESS)
		return r;
	if (msg.r_cmd.header.msg_id != SND_MSG_RET_CMD)
		return error_ret(&msg.r_ill, SND_MSG_GET_DSP_CMD_PORT);
	*cmd_port = msg.header.msg_remote_port;
	return r;
}


/*
 * Simple (non-dma) interaction routines
 */

kern_return_t snddriver_dspcmd_req_msg (
	port_t		cmd_port,		// valid dsp command port
	port_t		reply_port)		// where to recieve messages
{
	int t = (timeout < 0)? 0 : 1;
	snd_dspcmd_req_msg_t m;

	static const snd_dspcmd_req_msg_t M = {
		/* no name */		0,
		/* msg_simple */	TRUE,
		/* msg_size */		sizeof(snd_dspcmd_req_msg_t),
		/* msg_type */		MSG_TYPE_NORMAL,
		/* msg_remote_port */	0,
		/* msg_reply_port */	0,
		/* msg_id */		SND_MSG_DSP_REQ_MSG
	};

	m = M;
	m.msg_remote_port = cmd_port;
	m.msg_local_port = reply_port;
	return msg_send((msg_header_t *)&m,
				 t? SEND_TIMEOUT : MSG_OPTION_NONE, timeout);
}

kern_return_t snddriver_dspcmd_req_err (
	port_t		cmd_port,		// valid dsp command port
	port_t		reply_port)		// where to recieve messages
{
	int t = (timeout < 0)? 0 : 1;
	snd_dspcmd_req_err_t m;

	static const snd_dspcmd_req_err_t M = {
		/* no name */		0,
		/* msg_simple */	TRUE,
		/* msg_size */		sizeof(snd_dspcmd_req_err_t),
		/* msg_type */		MSG_TYPE_NORMAL,
		/* msg_remote_port */	0,
		/* msg_reply_port */	0,
		/* msg_id */		SND_MSG_DSP_REQ_ERR
	};

	m = M;
	m.msg_remote_port = cmd_port;
	m.msg_local_port = reply_port;
	return msg_send((msg_header_t *)&m,
				 t? SEND_TIMEOUT : MSG_OPTION_NONE, timeout);
}

#define OLD_DSP_COND 0

kern_return_t snddriver_dspcmd_req_condition (	//?
	port_t		cmd_port,		// valid dsp command port
	u_int		mask,			// mask of flags in condition
	u_int		flags,			// value of flags in condition
	int		priority,		// priority of this transaction
	port_t		reply_port)		// where to receive messages
{
#if OLD_DSP_COND
	msg_header_t rmsg = {
		/* no name */		0,
		/* msg_simple */	TRUE,
		/* msg_size */		sizeof(msg_header_t),
		/* msg_type */		MSG_TYPE_NORMAL,
		/* msg_remote_port */	reply_port,
		/* msg_local_port */	PORT_NULL,
		/* msg_id */		54321 //SND_MSG_DSP_COND_TRUE
	};
#endif OLD_DSP_COND
	msg_header_t *msg;
	kern_return_t r;
	int atomic = 0;
	msg = sndmsg_dspcmd_msg(cmd_port, thread_reply(), priority, atomic);
#if OLD_DSP_COND
	msg = sndmsg_old_dsp_condition(msg,mask,flags);
	msg = sndmsg_dsp_ret_msg(msg, &rmsg);
#else OLD_DSP_COND
	msg = sndmsg_dsp_condition(msg, mask, flags, reply_port);
#endif OLD_DSP_COND
	r = msg_rpc(msg, msg_rpc_options, MSG_SIZE_MAX, timeout, timeout);
	if (r != KERN_SUCCESS)
	  return r;
	r = snd_return_code((snd_illegal_msg_t *)msg);
	free(msg);
	return r;
}

kern_return_t snddriver_dsp_set_flags (
	port_t		cmd_port,		// valid dsp command port
	u_int		mask,			// mask of flags to affect
	u_int		flags,			// values of affected flags
	int		priority)		// priority of this transaction
{
	msg_header_t *msg;
	kern_return_t r;
	int atomic = 0;

	msg = sndmsg_dspcmd_msg(cmd_port, thread_reply(), priority, atomic);
	msg = sndmsg_dsp_host_flag(msg, mask, flags);
	r = msg_rpc(msg, msg_rpc_options, MSG_SIZE_MAX, timeout, timeout);
	if (r != KERN_SUCCESS)
	  return r;
	r = snd_return_code((snd_illegal_msg_t *)msg);
	free(msg);
	return r;
}

kern_return_t snddriver_dsp_host_cmd (
	port_t		cmd_port,		// valid dsp command port
	u_int		host_command,		// host command to execute
	int		priority)		// priority of this transaction
{
	msg_header_t *msg;
	kern_return_t r;
	int atomic = 0;

	msg = sndmsg_dspcmd_msg(cmd_port, thread_reply(), priority, atomic);
	msg = sndmsg_dsp_host_command(msg, host_command);
	r = msg_rpc(msg, msg_rpc_options, MSG_SIZE_MAX, timeout, timeout);
	if (r != KERN_SUCCESS)
	  return r;
	r = snd_return_code((snd_illegal_msg_t *)msg);
	free(msg);
	return r;
}

/* New for 2.0 */
kern_return_t snddriver_dsp_read_data (
	port_t		cmd_port,		// valid command port
	void		**data,			// ** or *0 or 0
	int		count,			// count of data elements
	int		data_size,		// bytes per data element
	int		priority)		// priority of this transaction
{
	msg_header_t *msg;
	kern_return_t r;
	int atomic = 0;
	void *rdata;
	void *data_ptr;
	int got_ill_msg = 0;
	int got_data = 0;
	/*** FIXME: Recorded data currently always sent back in-line ***/
	int max_read_data_count = (MSG_SIZE_MAX-sizeof(snd_recorded_data_t)
	   /*** FIX snd_dspcmd.c to be able to add this: +sizeof(pointer_t)*/);

	/*
	 * FIXME: Driver should create whole thing and vm_copy it 
	 * back to us.  Currently, only in-line data is sent back
	 * in the message frame, forcing us to copy it.
	 */
	if (data && !(*data)) {	/* support API for later implementation */
	    vm_allocate(task_self(),(vm_address_t *)data,
			data_size * count, TRUE);
	}

	if (data_size<=0) {
	    data_size = 4;	/* to keep the peace downstairs */
	    data = 0;		/* either means toss the data */
	}
	data_ptr = (data? *data : data);
	while (count) {
	    int nread = MIN(max_read_data_count/data_size,count);
	    got_ill_msg = 0;
	    got_data = 0;
	    count -= nread;
	    /*** FIXME: No need to malloc each time.  Use static frame. ***/
	    msg = sndmsg_dspcmd_msg(cmd_port, 
				    (data && data_size? 
				     thread_reply() : PORT_NULL), 
				    priority, atomic);
	    msg = sndmsg_dsp_read_data(msg, data_size, nread);
	    /*** FIXME: Make rpc work since it's faster
	      r=msg_rpc(msg, msg_rpc_options, MSG_SIZE_MAX,timeout,timeout);
	     ***/
	    r = msg_send(msg, MSG_OPTION_NONE, timeout);
	    if (r != KERN_SUCCESS)
	      return r;
	    if (!data)
	      return 0;		/* used to flush DSP data */
	    while (!got_ill_msg || !got_data) { /* msg order unpredictable */
		msg->msg_local_port = thread_reply();
		msg->msg_remote_port = cmd_port;
		msg->msg_size = MSG_SIZE_MAX;
		msg->msg_id = 0;
		r = msg_receive(msg, MSG_OPTION_NONE, 0);
		if (r != KERN_SUCCESS)
		  return r;
		switch (msg->msg_id) {
		default:
#if DPRINT
		    fprintf(stderr,"*** snddriver_dsp_read_data: "
			    "Unexpected msg id %d received "
			    "while expecting SND_MSG_ILLEGAL_MSG ", 
			    "or SND_MSG_RECORDED_DATA.\n", 
			    msg->msg_id);
#endif
		    break;
		case SND_MSG_ILLEGAL_MSG:/* FIXME: How to turn this one off? */
		    if (((snd_illegal_msg_t *)msg)->ill_error != SND_NO_ERROR){
#if DPRINT
			fprintf(stderr,
				"\t(snddriver_dsp_read_data: ill_msgid: %d)\n",
				((snd_illegal_msg_t *)msg)->ill_msgid);
			fprintf(stderr,
				"\t(snddriver_dsp_read_data: error: %d)\n",
				((snd_illegal_msg_t *)msg)->ill_error);
#endif
			r=error_ret((snd_illegal_msg_t *)msg,SND_MSG_DSP_MSG);
			return r;
		    }
		    got_ill_msg = 1;
		    break;
		case SND_MSG_RECORDED_DATA:
		    /*
		     * Copy in the recorded data
		     */
		    rdata=(void*)&(((snd_recorded_data_t*)msg)->recorded_data);
		    bcopy((char *)rdata, (char *)data_ptr, data_size * nread);
		    // memmove((char *)data_ptr,(char *)rdata,data_size*nread);
		    got_data = 1;
		    ((char *)data_ptr) += data_size*nread;
		    break;
		}		/* switch(msg->msg_id) */
	    }			/* while (!got_ill_msg || !got_data) */
	    /*** FIXME: Do the following when recorded data is really 
	      allocated in the driver and vm_copied up, and we've copied it
	      (which happens when the user passes a valid buffer pointer).
	      vm_deallocate(task_self(),(vm_address_t)rdata,data_size*nread);
	     ***/
	    free(msg);		/* FIXME: Move out of loop */
	}			/* while (count) */
	
	return 0;
}


/* In 1.0, the following was named snddriver_dsp_read(). */
kern_return_t snddriver_dsp_read_messages (
	port_t		cmd_port,		// valid command port
	void		*data,			// pointer to buffer
	int		*count,			// count of data elements
	int		data_size,		// bytes per data element
	int		priority)		// priority of this transaction
{
	static int *buffered_transfers=0, buffered_transfer_size=0;
	msg_header_t *msg = (msg_header_t *)malloc(MSG_SIZE_MAX);
	int err = 0, rsize, i, *rdata, remaining_count = *count;
	unsigned char *bdata;
	short *sdata;
	static port_t reply_port = 0;
	unsigned char *rdp;
    
	if (!reply_port) {
	    err = port_allocate(task_self(), &reply_port);
	    if (err) return err;
	}

	while (remaining_count > 0) {
	    if (buffered_transfer_size) {
		rdata = (int *)((snd_dsp_msg_t*)msg)->data;
		memmove((char *)(rdata),
			(char *)buffered_transfers,
			buffered_transfer_size*sizeof(int));
		rsize = buffered_transfer_size;
		buffered_transfer_size = 0;
	    } else {
		err = snddriver_dspcmd_req_msg(cmd_port, reply_port);
		if (err) return err;
		msg->msg_size = MSG_SIZE_MAX;
		msg->msg_local_port = reply_port;
		err = msg_receive(msg, MSG_OPTION_NONE, 0);
		if (err) {
		    *count -= remaining_count;
		    return err;
		}
		if (msg->msg_id != SND_MSG_RET_DSP_MSG) {
		    *count -= remaining_count;
		    return SND_BAD_MSG;
		}
		rsize = ((snd_dsp_msg_t *)msg)->dataType.msg_type_long_number;
		rdata = (int *)((snd_dsp_msg_t*)msg)->data;
	    }
	    if (rsize > remaining_count) {
		buffered_transfer_size = rsize - remaining_count;
		if (!buffered_transfers) 
		    buffered_transfers = (int *)malloc(MSG_SIZE_MAX);
		memmove((char *)buffered_transfers, 
			(char *)(rdata+remaining_count), 
			buffered_transfer_size*sizeof(int));
		rsize = remaining_count;
	    }
	    switch (data_size) {
		case sizeof(int):
		    memmove((char *)data, (char *)rdata, rsize*sizeof(int));
		    break;
		case sizeof(short):
		    sdata = (short *)data;
		    for (i=0; i<rsize; i++)
			*sdata++ = (short)(*rdata++);
		    break;
		case sizeof(char):
		    bdata = (unsigned char *)data;
		    for (i=0; i<rsize; i++)
			*bdata++ = (unsigned char)(*rdata++);
		    break;
		case 3:
		    rdp = (unsigned char *)rdata;
		    bdata = (unsigned char *)data;
		    for (i=0; i<rsize; i++) {
			*bdata++ = *rdp++;
			*bdata++ = *rdp++;
			*bdata++ = *rdp++;
		    }
		    break;
	    }
	    data = (void *)((int *)data + rsize);
	    remaining_count -= rsize;
	}
	free(msg);
//	*count -= remaining_count;
	return err;
}


kern_return_t snddriver_dsp_read (
	port_t		cmd_port,		// valid command port
	void		*data,			// pointer to buffer
	int		*count,			// count of data elements
	int		data_size,		// bytes per data element
	int		priority)		// priority of this transaction
{
    if (   
	!(dsp_protocol & SNDDRIVER_DSP_PROTO_RAW) /* Raw mode */
	|| dsp_protocol & SNDDRIVER_DSP_PROTO_DSPMSG /* DSP messages */
	|| dsp_protocol & SNDDRIVER_DSP_PROTO_DSPERR /* DSP error messages */
	|| dsp_protocol & SNDDRIVER_DSP_PROTO_C_DMA ) /* Complex DMA mode */
      return snddriver_dsp_read_messages(cmd_port,data,count,
					 data_size,priority);
    else			/* raw-mode read */
      return snddriver_dsp_read_data(cmd_port,&data,*count,
				     data_size,priority);
}


kern_return_t snddriver_dsp_write (
	port_t		cmd_port,		// valid command port
	void		*data,			// pointer to buffer
	int		count,			// count of data elements
	int		data_size,		// bytes per data element
	int		priority)		// priority of this transaction
{
	msg_header_t *msg;
	kern_return_t r;
	int atomic = 0;

	msg = sndmsg_dspcmd_msg(cmd_port, thread_reply(), priority, atomic);
	msg = sndmsg_dsp_write_data(msg, (pointer_t)data, data_size, count);
	r = msg_rpc(msg, msg_rpc_options, MSG_SIZE_MAX, timeout, timeout);
	if (r != KERN_SUCCESS)
	  return r;
	r = snd_return_code((snd_illegal_msg_t *)msg);
	free(msg);
	return r;
}

kern_return_t snddriver_dsp_reset (
	port_t		cmd_port,		// valid command port
	int		priority)		// priority of this transaction
{
	msg_header_t *msg;
	kern_return_t r;
	int atomic = 0;
    
	msg = sndmsg_dspcmd_msg(cmd_port, thread_reply(), priority, atomic);
	msg = sndmsg_dspreset(msg);
	r = msg_rpc(msg, msg_rpc_options, MSG_SIZE_MAX, timeout, timeout);
	if (r != KERN_SUCCESS)
	  return r;
	r = snd_return_code((snd_illegal_msg_t *)msg);
	free(msg);
	return r;
}

kern_return_t snddriver_dsp_boot (
	port_t		cmd_port,		// valid command port
	int		*bootImage,		// on-chip instructions
	int		bootImageSize,		// instruction count
	int		priority)		// priority of this transaction
{
	msg_header_t *msg;
	int r;
	int atomic = 0;
    
	msg = sndmsg_dspcmd_msg(cmd_port, thread_reply(), priority, atomic);
	msg = sndmsg_dspreset(msg);
	msg = sndmsg_dsp_write_data(msg,
			      (pointer_t)bootImage, sizeof(int), 
			      bootImageSize);
	msg = sndmsg_dsp_host_flag(msg,SNDDRIVER_ICR_HF0,SNDDRIVER_ICR_HF0);
	msg = sndmsg_dsp_host_flag(msg,SNDDRIVER_ICR_HF0,0);
	r = msg_rpc(msg, msg_rpc_options, MSG_SIZE_MAX, timeout, timeout);
	if (r != KERN_SUCCESS)
	  return r;
	r = snd_return_code((snd_illegal_msg_t *)msg);
	free(msg);
	return r;
}

/*
 * Set number of dma descriptors in stream.
 * New for 2.0.
 */
kern_return_t snddriver_stream_ndma (
	port_t		stream_port,		// valid stream port
	int		tag,			// tag to identify stream
	int		ndma)			// number of dma descs in stream
{
    int err;
    msg_header_t *msg;
    msg = snd_stream_msg(stream_port, thread_reply(), tag);
    msg = snd_stream_ndma(msg, ndma);
    err = snd_send_stream_msg(msg);
    free(msg);
    return err;
}

/*
 * Re-allocate the device port.  This causes all current connections to be
 * terminated. (New in 2.0)
 */
kern_return_t snddriver_new_device_port (
	port_t		device_port,	// current valid device port
	port_t		host_priv_port,	// from host_priv_self()
	port_t		*new_dev_port)	// new device port
{
	int r;
	union {
		snd_new_device_t	g_new_device;
		snd_ret_port_t		r_new_device;
		snd_illegal_msg_t	r_ill;
		msg_header_t		header;
	} msg;
	static const snd_new_device_t M = {
		{
			/* no name */		0,
			/* msg_simple */	FALSE,
			/* msg_size */		sizeof(snd_new_device_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_NEW_DEVICE_PORT
		},
		{
			/* msg_type_name = */		MSG_TYPE_PORT,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		}
	};

	msg.g_new_device = M;
	msg.header.msg_remote_port = device_port;
	msg.header.msg_local_port = thread_reply();
	msg.g_new_device.priv = host_priv_port;
	
	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r != KERN_SUCCESS)
		return r;
	if (msg.header.msg_id != SND_MSG_RET_DEVICE)
		return error_ret(&msg.r_ill, SND_MSG_NEW_DEVICE_PORT);
	*new_dev_port = msg.header.msg_remote_port;
	return r;
}

/*
 * Generic reset owner.
 */
static kern_return_t snddriver_reset_owner (
	port_t		device_port,	// valid device port
	port_t		old_owner_port,	// old dsp owner port
	port_t		new_owner_port,	// new dsp owner port
	port_t		new_negotiation,// new dsp negotiation port
	int		msg_id)
{
	register int r;
	union {
		snd_illegal_msg_t	r_ill;
		snd_reset_owner_t	s_own;
		msg_header_t		header;
	} msg;
	static const snd_reset_owner_t M = {
		{
			/* no name */		0,
			/* msg_simple */	FALSE,
			/* msg_size */		sizeof(snd_reset_owner_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		0
		},
		{
			/* msg_type_name = */		MSG_TYPE_PORT,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE
		},
		0,
		{
			/* msg_type_name = */		MSG_TYPE_PORT,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE
		},
		0,
		{
			/* msg_type_name = */		MSG_TYPE_PORT,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE
		},
		0
	};

	msg.s_own = M;
	msg.header.msg_id = msg_id;
	msg.header.msg_remote_port = device_port;
	msg.header.msg_local_port = thread_reply();
	msg.s_own.old_owner = old_owner_port;
	msg.s_own.new_owner = new_owner_port;
	msg.s_own.new_negotiation = new_negotiation;

	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r != KERN_SUCCESS)
		return r;
	return normal_ret(&msg.r_ill, msg_id);
}

/*
 * Exchange the current dsp owner port with a new one.  New for 2.0.
 */
kern_return_t snddriver_reset_dsp_owner (
	port_t		device_port,	// valid device port
	port_t		old_owner_port,	// old dsp owner port
	port_t		new_owner_port,	// new dsp owner port
	port_t		new_negotiation)// new dsp negotiation port
{
    return snddriver_reset_owner(device_port, old_owner_port, new_owner_port,
				 new_negotiation, SND_MSG_RESET_DSPOWNER);
}

/*
 * Exchange the current sndin owner port with a new one.  New for 2.0.
 */
kern_return_t snddriver_reset_sndin_owner (
	port_t		device_port,	// valid device port
	port_t		old_owner_port,	// old sndin owner port
	port_t		new_owner_port,	// new sndin owner port
	port_t		new_negotiation)// new sndin negotiation port
{
    return snddriver_reset_owner(device_port, old_owner_port, new_owner_port,
				 new_negotiation, SND_MSG_RESET_SNDINOWNER);
}

/*
 * Exchange the current sndout owner port with a new one.  New for 2.0.
 */
kern_return_t snddriver_reset_sndout_owner (
	port_t		device_port,	// valid device port
	port_t		old_owner_port,	// old sndout owner port
	port_t		new_owner_port,	// new sndout owner port
	port_t		new_negotiation)// new sndout negotiation port
{
    return snddriver_reset_owner(device_port, old_owner_port, new_owner_port,
				 new_negotiation, SND_MSG_RESET_SNDOUTOWNER);
}

/*
 * DMA and stream setup functions
 */

static kern_return_t snddriver_get_stream (
	port_t		device_port,	// valid device port
	port_t		owner_port,	// valid soundout/in/dsp owner port
	port_t		*stream_port,	// returned stream_port
	u_int		stream)		// stream to/from what?
{
	int r;
	union {
		snd_get_stream_t	g_stream;
		snd_ret_port_t		r_stream;
		snd_illegal_msg_t	r_ill;
		msg_header_t		header;
	} msg;
	static const snd_get_stream_t M = {
		{
			/* no name */		0,
			/* msg_simple */	FALSE,
			/* msg_size */		sizeof(snd_get_stream_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_GET_STREAM
		},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0,
		{
			/* msg_type_name = */		MSG_TYPE_PORT,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0
	};

	msg.g_stream = M;
	msg.header.msg_remote_port = device_port;
	msg.header.msg_local_port = thread_reply();
	msg.g_stream.owner = owner_port;
	msg.g_stream.stream = stream;
	
	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r != KERN_SUCCESS)
		return r;
	if (msg.header.msg_id != SND_MSG_RET_STREAM)
		return error_ret(&msg.r_ill, SND_MSG_GET_STREAM);
	*stream_port = msg.r_stream.header.msg_remote_port;
	return r;
}

static kern_return_t snddriver_dsp_chandata (
	port_t		cmd_port,	// valid dsp command port
	int		addr,		// .. of dsp buffer
	int		size,		// .. of dsp buffer
	int		skip,		// dma skip factor
	int		space,		// dsp space of buffer
	int		mode,		// mode of dma [1..5]
	int		chan)		// channel for dma
{
	register int r;
	union {
		snd_dspcmd_chandata_t   s_chandata;
		snd_illegal_msg_t	r_ill;
		msg_header_t		header;
	} msg;
	static const snd_dspcmd_chandata_t M = {
		{
			/* no name */		0,
			/* msg_simple */	TRUE,
			/* msg_size */		sizeof(snd_dspcmd_chandata_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_DSP_CHANDATA
		},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		6,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		}
	};

	msg.s_chandata = M;
	msg.header.msg_remote_port = cmd_port;
	msg.header.msg_local_port = thread_reply();

	msg.s_chandata.addr = addr;
	msg.s_chandata.size = size;
	msg.s_chandata.skip = skip;
	msg.s_chandata.space = space;
	msg.s_chandata.mode = mode;
	msg.s_chandata.chan = chan;

	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r != KERN_SUCCESS)
		return r;
	return normal_ret(&msg.r_ill, SND_MSG_DSP_CHANDATA);
}

/* New for 2.0 */
/*** FIXME: validate owner_port before doing the operation ***/
kern_return_t snddriver_set_sndout_bufsize (
	port_t		dev_port,		// valid device port
	port_t		owner_port,		// valid owner port
	int		sobsize)		// so buf size
{
    if (sobsize > 0 ) {
	so_buf_size = sobsize;
	if (so_buf_size > vm_page_size)
	    so_buf_size = vm_page_size;	/* FIXME: or should this be an error? */
	return KERN_SUCCESS;
    } else 
      return KERN_INVALID_ARGUMENT;
}

/* New for 2.0 */
/*** FIXME: validate owner_port before doing the operation ***/
kern_return_t snddriver_set_sndout_bufcount (
	port_t		dev_port,		// valid device port
	port_t		owner_port,		// valid owner port
	int		sobcount)		// so buf count
{
    if (sobcount > 0 ) {
	so_buf_count = sobcount;
	return KERN_SUCCESS;
    } else 
      return KERN_INVALID_ARGUMENT;
}

kern_return_t snddriver_stream_setup (
	port_t		dev_port,		// valid device port
	port_t		owner_port,		// valid owner port
	int		config,			// stream configuration
	int		buf_size,		// samples per buffer
	int		sample_size,		// bytes per sample
	int		low_water,		// low water mark
	int		high_water,		// high water mark
	int		*protocol,		// modified dsp protocol
	port_t		*stream_port)		// returned stream_port
{
    port_t cmd_port, sndout_stream_port;
    msg_header_t *msg; // only used for DSP->SoundOut stream.
    int r;
    int new_proto = *protocol;
    u_int stream = 0;
    
    if (so_buf_size <= 0)
	so_buf_size = vm_page_size;	/* default so_buf_size */

    if (!config) {
	free_stream_parms(*stream_port);
	return KERN_SUCCESS;
    }
    switch (config) {
	case SNDDRIVER_STREAM_TO_SNDOUT_44:
	case SNDDRIVER_STREAM_TO_SNDOUT_22:
	    if (sample_size != 2) return KERN_FAILURE;
	    if (config==SNDDRIVER_STREAM_TO_SNDOUT_44)
		stream = SND_GD_SOUT_44;
	    else
		stream = SND_GD_SOUT_22;
	    r = snddriver_get_stream(dev_port,owner_port,stream_port,stream);
	    if (r != KERN_SUCCESS) return r;
	    /*
	     * Screwy API note: in this case the passed buf_size is used to
	     * configure the sound-out stream, not so_buf_size.
	     */
	    put_stream_parms(*stream_port,low_water,high_water,
			     buf_size,sample_size);
	    /* New for 2.0 - set the number of sndout buffers */
	    r = snddriver_stream_ndma(*stream_port, 0, so_buf_count);
	    return r;
	case SNDDRIVER_STREAM_FROM_SNDIN:
	    if (sample_size != 1) return KERN_FAILURE;
	    stream = SND_GD_SIN;
	    r = snddriver_get_stream(dev_port,owner_port,stream_port,stream);
	    put_stream_parms(*stream_port,low_water,high_water,
			     buf_size,sample_size);
	    return r;
	case SNDDRIVER_DMA_STREAM_FROM_DSP:
	case SNDDRIVER_STREAM_FROM_DSP:
	    /*** FIXME: should also support 3 bytes in some fashion ***/
	    if (sample_size != 1 && sample_size != 2 && sample_size != 4)
		return KERN_FAILURE;
	    new_proto |= SND_DSP_PROTO_C_DMA;
	    r = snddriver_get_dsp_cmd_port(dev_port,owner_port,&cmd_port);
	    if (r != KERN_SUCCESS) return r;
	    r = snddriver_dsp_chandata(cmd_port,0,buf_size,
				       0,0,sample_size,DSP_SO_CHAN);
	    if (r != KERN_SUCCESS) return r;
	    stream = SND_GD_DSP_OUT;
	    r = snddriver_get_stream(dev_port,owner_port, stream_port, stream);
	    if (r != KERN_SUCCESS) return r;
	    *protocol |= new_proto;
	    put_stream_parms(*stream_port,low_water,high_water,
			     buf_size,sample_size);
	    return KERN_SUCCESS;
	case SNDDRIVER_DMA_STREAM_TO_DSP:
	case SNDDRIVER_STREAM_TO_DSP:
	    /*** FIXME: should also support 3 bytes in some fashion ***/
	    if (sample_size != 1 && sample_size != 2 && sample_size != 4)
		return KERN_FAILURE;

	    if (config == SNDDRIVER_DMA_STREAM_TO_DSP)
	      new_proto |= SND_DSP_PROTO_C_DMA;
	    else /* config == SNDDRIVER_STREAM_TO_DSP */
	      new_proto |= SND_DSP_PROTO_SOUNDDATA;

	    r = snddriver_get_dsp_cmd_port(dev_port,owner_port,&cmd_port);
	    if (r != KERN_SUCCESS) return r;
	    r = snddriver_dsp_chandata(cmd_port,
				       0 /* dsp_buffer_address. p:0 means
					  memory space field holds channel# */,
				       buf_size,
				       2 /* dsp_skip_factor = channel no. */,
				       4 /* dsp_memory_space must be p = 4 */,
				       sample_size, 
				       DSP_SI_CHAN /* dsp-initiated write channel */);
	    /* Pre 2.0: r = snddriver_dsp_chandata(cmd_port,0,buf_size,
					       0,0,sample_size,DSP_SI_CHAN); */
	    if (r != KERN_SUCCESS) return r;
	    stream = 2 /* SND_GD_DSP_IN */;
	    r = snddriver_get_stream(dev_port,owner_port, stream_port, stream);
	    if (r != KERN_SUCCESS) return r;
	    *protocol |= new_proto;
	    put_stream_parms(*stream_port,low_water,high_water,
			     buf_size,sample_size);
	    return KERN_SUCCESS;
	case SNDDRIVER_STREAM_DSP_TO_SNDOUT_44:
	case SNDDRIVER_STREAM_DSP_TO_SNDOUT_22:
	    if (sample_size != 2) return KERN_FAILURE;
	    new_proto |= SND_DSP_PROTO_LINKOUT|SND_DSP_PROTO_C_DMA;
	    if (config == SNDDRIVER_STREAM_DSP_TO_SNDOUT_44) {
		new_proto |= SND_DSP_PROTO_HIGH;
		stream = SND_GD_SOUT_44;
	    } else
		stream = SND_GD_SOUT_22;
	    r = snddriver_get_dsp_cmd_port(dev_port,owner_port,&cmd_port);
	    if (r != KERN_SUCCESS) return r;
	    /*
	     * The DSP memory space, buffer address, and increment do not
	     * matter below, because the driver does not set them up.  When
	     * the DSP sends a DMA request for a sound-out buffer, the driver
	     * only looks at the channel number in the one-word DSP DMA 
	     * request.  The channel number must agree with the argument
	     * DSP_SO_CHAN below.  Currently, this is channel "1", so the
	     * word sent by the DSP to request a DMA to memory for a sound
	     * buffer will be 0x50001 (opcode 0x5, channel number 1).  This
	     * is an example of a DSP-initiated DMA read.
	     */
	    r = snddriver_dsp_chandata(cmd_port,
				       0 /* dsp buffer address */,
				       buf_size,
				       0 /* skip factor */,
				       0 /* space  */,
				       2 /* sample size */,
				       DSP_SO_CHAN /* Sound-out channel(=1)*/);
	    if (r != KERN_SUCCESS) return r;
	    r = snddriver_get_stream(dev_port,owner_port, stream_port, stream);
	    if (r != KERN_SUCCESS) return r;
	    *protocol |= new_proto;
	    /* New for 2.0 - use so_buf_size */
	    put_stream_parms(*stream_port, low_water, high_water,
			     so_buf_size, sample_size);
	    /* 	New for 2.0: 
		3/10/90/jos. stream options are normally set in 
		snddriver_start_{reading,writing}.  A link is automatic, 
		so we do it here. */
	    msg = snd_stream_msg(*stream_port, thread_reply(), 0);
	    /* Set the number of sndout buffers */
	    msg = snd_stream_ndma(msg, so_buf_count);
	    msg = snd_stream_options(msg, high_water, low_water, 
				     so_buf_size);
	    r = snd_send_stream_msg(msg);
	    return r;
	case SNDDRIVER_STREAM_THROUGH_DSP_TO_SNDOUT_22:
	case SNDDRIVER_STREAM_THROUGH_DSP_TO_SNDOUT_44:
	    new_proto |= SND_DSP_PROTO_SOUNDDATA;
	case SNDDRIVER_DMA_STREAM_THROUGH_DSP_TO_SNDOUT_22:
	case SNDDRIVER_DMA_STREAM_THROUGH_DSP_TO_SNDOUT_44:
	    /* The C_DMA bit here makes the read from the dsp use complex dma mode.
	       The lack of the SOUNDDATA bit implies that write to the dsp uses dma. */
	    new_proto |= SND_DSP_PROTO_C_DMA;
	    new_proto |= SND_DSP_PROTO_LINKOUT;
	    if (sample_size != 1 && sample_size != 2 && sample_size != 4)
		return KERN_FAILURE;
	    if (config == SNDDRIVER_STREAM_THROUGH_DSP_TO_SNDOUT_44 ||
		config == SNDDRIVER_DMA_STREAM_THROUGH_DSP_TO_SNDOUT_44)
		new_proto |= SND_DSP_PROTO_HIGH;
	    r = snddriver_get_dsp_cmd_port(dev_port,owner_port,&cmd_port);
	    if (r != KERN_SUCCESS) return r;
	    /*
	     * Use chandata to specify some options for the streams in to and
	     * out of the dsp.  Some other options are set below for the
	     * sndout stream using a stream options message.
	     */
	    r = snddriver_dsp_chandata(cmd_port,0,buf_size,0,0,2,DSP_SO_CHAN);
	    if (r != KERN_SUCCESS) return r;
	    r = snddriver_dsp_chandata(cmd_port,
				       0 /* dsp_buffer_address. p:0 means
					  memory space field holds channel# */,
				       buf_size,
				       2 /* dsp_skip_factor = channel no. */,
				       4 /* dsp_memory_space must be p = 4 */,
				       sample_size, 
				       DSP_SI_CHAN /* dsp-initiated write channel */);
	    /* Pre 2.0: r = snddriver_dsp_chandata(cmd_port,0,buf_size,
	    					0,0,sample_size,DSP_SI_CHAN); */
	    if (r != KERN_SUCCESS) return r;
	    /*
	     * Save options that snddriver_stream_start_writing() will use to
	     * set up the stream to the dsp.
	     */
	    stream = SND_GD_DSP_IN;
	    r = snddriver_get_stream(dev_port,owner_port, stream_port, stream);
	    if (r != KERN_SUCCESS) return r;
	    put_stream_parms(*stream_port,low_water,high_water,
			     buf_size,sample_size);
	    /*
	     * New for 2.0 - set the number and size of sndout buffers.
	     */
	    if (config == SNDDRIVER_STREAM_THROUGH_DSP_TO_SNDOUT_44 ||
		config == SNDDRIVER_DMA_STREAM_THROUGH_DSP_TO_SNDOUT_44)
		stream = SND_GD_SOUT_44;
	    else
		stream = SND_GD_SOUT_22;
	    r = snddriver_get_stream(dev_port,owner_port, &sndout_stream_port, stream);
	    if (r != KERN_SUCCESS) return r;
	    msg = snd_stream_msg(sndout_stream_port, thread_reply(), 0);
	    msg = snd_stream_ndma(msg, so_buf_count);
	    msg = snd_stream_options(msg, high_water, low_water, 
				     so_buf_size);
	    r = snd_send_stream_msg(msg);
	    *protocol |= new_proto;
	    return r;
	case SNDDRIVER_STREAM_FROM_SNDIN_THROUGH_DSP:
	    new_proto |= SND_DSP_PROTO_C_DMA;
	    if (sample_size != 1 && sample_size != 2 && sample_size != 4)
	      return KERN_FAILURE;
	    r = snddriver_get_dsp_cmd_port(dev_port,owner_port,&cmd_port);
	    if (r != KERN_SUCCESS) return r;
	    r = snddriver_dsp_chandata(cmd_port,0,buf_size,0,0,2,DSP_SO_CHAN);
	    if (r != KERN_SUCCESS) return r;
	    r = snddriver_dsp_chandata(cmd_port,0,buf_size,
	    					0,0,sample_size,DSP_SI_CHAN);
	    if (r != KERN_SUCCESS) return r;
	    stream = SND_GD_DSP_IN;
	    r = snddriver_get_stream(dev_port,owner_port, stream_port, stream);
	    if (r != KERN_SUCCESS) return r;
	    *protocol |= new_proto;
	    put_stream_parms(*stream_port,low_water,high_water,
			     buf_size,sample_size);
	    return KERN_SUCCESS;
	case SNDDRIVER_STREAM_SNDIN_TO_DSP:
	    /*
	     * This initial (untested) implementation is a copy of 
	     * STREAM_TO_DSP with SO_CHAN changed to SI_CHAN.
	     */
	    new_proto |= SND_DSP_PROTO_C_DMA;
	    r = snddriver_get_dsp_cmd_port(dev_port,owner_port,&cmd_port);
	    if (r != KERN_SUCCESS) return r;
	    r = snddriver_dsp_chandata(cmd_port,0,buf_size,
						0,0,sample_size,DSP_SI_CHAN);
	    if (r != KERN_SUCCESS) return r;
	    stream = SND_GD_DSP_OUT;
	    r = snddriver_get_stream(dev_port,owner_port, stream_port, stream);
	    if (r != KERN_SUCCESS) return r;
	    *protocol |= new_proto;
	    put_stream_parms(*stream_port,low_water,high_water,
	    						buf_size,sample_size);
	    return KERN_SUCCESS;
	default:
	    return KERN_FAILURE; //!
    }
}


kern_return_t snddriver_dsp_protocol (
	port_t		device_port,		// valid device port
	port_t		owner_port,		// port registered as owner
	int		protocol)		// protocol bits
{
	register int r;
	union {
		snd_dsp_proto_t	        s_proto;
		snd_illegal_msg_t	r_ill;
		msg_header_t		header;
	} msg;
	static const snd_dsp_proto_t M = {
		{
			/* no name */		0,
			/* msg_simple */	FALSE,
			/* msg_size */		sizeof(snd_dsp_proto_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_DSP_PROTO
		},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0,
		{
			/* msg_type_name = */		MSG_TYPE_PORT,
			/* msg_type_size = */		32,
			/* msg_type_number = */		1,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0
	};

	msg.s_proto = M;
	msg.header.msg_remote_port = device_port;
	msg.header.msg_local_port = thread_reply();
	msg.s_proto.owner = owner_port;

	msg.s_proto.proto = protocol;
	dsp_protocol = protocol; /* static global used by ...dsp_read() */

	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r != KERN_SUCCESS)
		return r;
	return normal_ret(&msg.r_ill, SND_MSG_DSP_PROTO);
}


/*
 * DMA functions
 */

/*
 * User-initiated dma transfer to dsp. See programming examples. (New in 2.0.)
 */
kern_return_t snddriver_dsp_dma_write (
	port_t		cmd_port,	// valid dsp command port
	int		size,		// # dsp words to transfer
	int		mode,		// mode of dma [1..5]
	pointer_t	data)		// data to output
{
	register int r, dsize, msize;
	snd_dspcmd_dma_t s_dmaout;
	snd_illegal_msg_t r_msg;

	static const snd_dspcmd_dma_t M = {
		{
			/* no name */		0,
			/* msg_simple */	FALSE,
			/* msg_size */		sizeof(snd_dspcmd_dma_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_DSP_DMAOUT
		},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		5,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		},
		0, 0, 0, 0, 0,
		{
			{
				/* msg_type_name = */		0,
				/* msg_type_size = */		0,
				/* msg_type_number = */		0,
				/* msg_type_inline = */		FALSE,
				/* msg_type_longform = */	TRUE,
				/* msg_type_deallocate = */	FALSE,
			},
			/* msg_type_long_name = */	MSG_TYPE_INTEGER_8,
			/* msg_type_long_size = */	8,
			/* msg_type_long_number = */	0,
		}
	};

	s_dmaout = M;
	s_dmaout.header.msg_remote_port = cmd_port;
	s_dmaout.header.msg_local_port = thread_reply();

	/*** FIXME: The following 3 lines ***/
	s_dmaout.addr = 0;	/* DSP address 0 */
	s_dmaout.skip = 0;	/* channel number = "user request" channel */
	s_dmaout.space = 4;	/* DSP memory space "p" */
	/*** will be replaced by ***/
	/*** s_dmaout.channel = 0; /@ channel number = "user request" chan */
	/*** when the driver gets cleaned up ***/

	s_dmaout.size = size;
	s_dmaout.mode = mode;

	/*
	 * Send down the data, out-of-line.
	 */
	dsize = mode * size;
	if (dsize > vm_page_size || ((data+dsize-1) ^ data) & vm_page_size)
	  return SND_BAD_PARM;	/* data crosses a page boundary */

	if (data&0xF)
	  return SND_BAD_PARM;	/* data not quad-aligned */

	msize = sizeof(s_dmaout) - sizeof(s_dmaout.data) + dsize;

	s_dmaout.dataType.msg_type_long_number = dsize;

	(pointer_t *) s_dmaout.data = data;
	msize = sizeof(s_dmaout);

	r = msg_send(&s_dmaout.header, MSG_OPTION_NONE, 0);
	if (r != KERN_SUCCESS)
		return r;

	r_msg.header = s_dmaout.header;
	r = msg_receive(&r_msg.header, MSG_OPTION_NONE, 0);


#if DPRINT
switch (r_msg.header.msg_id)
{
case SND_MSG_ILLEGAL_MSG:
	if (r_msg.ill_error != SND_NO_ERROR)
	{
		fprintf(stderr,"Write (1): Got ILLEGAL message\n");
		fprintf(stderr,"ill_msgid: %d ", r_msg.ill_msgid);
		fprintf(stderr,"ill_error: %d\n", r_msg.ill_error);
	}
	break;
case SND_MSG_RECORDED_DATA:
	fprintf(stderr,"Write (1): Got RECORDED DATA msg\n");
	break;
case SND_MSG_COMPLETED:
	fprintf(stderr,"Write (1): Got COMPLETED msg\n");
	break;
default:
	fprintf(stderr,"Write (1): Got %d msg\n", r_msg.header.msg_id);
	break;
}
#endif

#if 0
	r_msg.header = s_dmaout.header;
	r = msg_receive(&r_msg.header, MSG_OPTION_NONE, 0);
fprintf(stderr,"Write (2): Got ");
switch (r_msg.header.msg_id)
{
case SND_MSG_ILLEGAL_MSG:
	fprintf(stderr,"ILLEGAL message\n");
	break;
case SND_MSG_RECORDED_DATA:
	fprintf(stderr,"RECORDED DATA msg\n");
	break;
case SND_MSG_COMPLETED:
	fprintf(stderr,"COMPLETED msg\n");
	break;
default:
	fprintf(stderr,"%d msg\n", r_msg.header.msg_id);
	break;
}
#endif

        if (r_msg.header.msg_id == SND_MSG_ILLEGAL_MSG && 
			r_msg.ill_error != SND_NO_ERROR)
	{
#if DPRINT
	    fprintf(stderr,"\t(snddriver_dsp_dma_write: ill_msgid: %d)\n", r_msg.ill_msgid);
		fprintf(stderr,"\t(snddriver_dsp_dma_write: error: %d)\n", r_msg.ill_error);
#endif
		r = r_msg.ill_error;
	}
	return r;
}


/*
 * User-initiated dma from dsp. See programming examples. (New in 2.0.)
 */
kern_return_t snddriver_dsp_dma_read (
	port_t		cmd_port,	// valid dsp command port
	int		size,		// .. of dsp buffer in words
	int		mode,		// mode of dma [1..5]
	pointer_t	*data)		// where data is put
{
	register int r, n;
	int done;
	union {
		snd_recorded_data_t data;
		snd_illegal_msg_t illegal;
	} s_rec;
	snd_dspcmd_dma_t s_dmain;
	static const snd_dspcmd_dma_t M = {
		{
			/* no name */		0,
			/* msg_simple */	TRUE,
			/* msg_size */		sizeof(s_dmain),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_DSP_DMAIN
		},
		{
			/* msg_type_name = */		MSG_TYPE_INTEGER_32,
			/* msg_type_size = */		32,
			/* msg_type_number = */		5,
			/* msg_type_inline = */		TRUE,
			/* msg_type_longform = */	FALSE,
			/* msg_type_deallocate = */	FALSE,
		}
	};

	s_dmain = M;
	s_dmain.header.msg_remote_port = cmd_port;
	s_dmain.header.msg_local_port = thread_reply();

	/*** FIXME: The following 3 lines ***/
	s_dmain.addr = 0;	/* DSP address 0 */
	s_dmain.skip = 0;	/* channel number = "user request" channel */
	s_dmain.space = 4;	/* DSP memory space "p" */
	/*** will be replaced by ***/
	/*** s_dmain.channel = 0; /@ channel number = "user request" channel */
	/*** when the driver gets cleaned up ***/

	s_dmain.size = size;
	s_dmain.mode = mode;

	r = msg_send(&s_dmain.header, MSG_OPTION_NONE, 0);
	if (r != KERN_SUCCESS)
		return r;

	s_rec.data.header.msg_id = 0;
	done = 0;
	while (done == 0)
	{
	    s_rec.data.header.msg_local_port = thread_reply();
	    s_rec.data.header.msg_remote_port = cmd_port;
	    s_rec.data.header.msg_size = sizeof(s_rec);
	    s_rec.data.header.msg_id = 0;
	    r = msg_receive(&s_rec.data.header, MSG_OPTION_NONE, 0);

	    switch (s_rec.data.header.msg_id)
	    {
		case SND_MSG_ILLEGAL_MSG:
			if (s_rec.illegal.ill_error != SND_NO_ERROR) done = 1;
#if DPRINT
			fprintf(stderr,"Got ILLEGAL message: %d\n",
						s_rec.illegal.ill_error);
#endif
			break;
		case SND_MSG_RECORDED_DATA:
			done = 1;
#if DPRINT
			fprintf(stderr,"Got RECORDED DATA msg\n");
#endif
			break;
		case SND_MSG_COMPLETED:
#if DPRINT
			fprintf(stderr,"Got COMPLETED msg\n");
#endif
			break;
		default:
#if DPRINT
			fprintf(stderr,"Got %d msg\n", 
				s_rec.data.header.msg_id);
#endif
			break;
	    }

	    if (s_rec.data.header.msg_id == SND_MSG_ILLEGAL_MSG && 
			s_rec.illegal.ill_error != SND_NO_ERROR)
	    {
#if DPRINT
		fprintf(stderr,"\t(snddriver_dsp_dma_read: ill_msgid: %d)\n", 
			s_rec.illegal.ill_msgid);
		fprintf(stderr,"\t(snddriver_dsp_dma_read: error: %d)\n", 
			s_rec.illegal.ill_error);
#endif
		r = error_ret(&s_rec.illegal, SND_MSG_DSP_DMAOUT);
	    }

	    if (s_rec.data.header.msg_id == SND_MSG_RECORDED_DATA)
	    {
		n = s_rec.data.dataType.msg_type_long_number *
	    	s_rec.data.dataType.msg_type_long_size / 8;

		if (n == size * mode) {
			*data = s_rec.data.recorded_data;
			r = KERN_SUCCESS;
		} else
			r = KERN_FAILURE;
	    }
	}
#if 0
s_rec.data.header.msg_local_port = thread_reply();
s_rec.data.header.msg_remote_port = cmd_port;
s_rec.data.header.msg_size = sizeof(s_rec);
s_rec.data.header.msg_id = 0;
r = msg_receive(&s_rec.data.header, MSG_OPTION_NONE, 0);

#if DPRINT
fprintf(stderr,"Read: Got ");
switch (s_rec.data.header.msg_id)
{
case SND_MSG_ILLEGAL_MSG:
	fprintf(stderr,"ILLEGAL message\n");
	break;
case SND_MSG_RECORDED_DATA:
	fprintf(stderr,"RECORDED DATA msg\n");
	break;
case SND_MSG_COMPLETED:
	fprintf(stderr,"COMPLETED msg\n");
	break;
default:
	fprintf(stderr,"%d msg\n", s_rec.data.header.msg_id);
	break;
}
#endif

#endif
	return r;
}


/*
 * Abort an in-progress dma.
 */
kern_return_t snddriver_dspcmd_abortdma (
	port_t		cmd_port,	// valid dsp command port
	int		*dma_state,	// returned dma state
	vm_address_t	*start,		// returned dma start address
	vm_address_t	*stop,		// returned dma stop address
	vm_address_t	*next)		// returned dma next address
{
    return KERN_FAILURE;
}


/*
 * Stream interaction functions
 */
kern_return_t snddriver_stream_start_reading (
	port_t		stream_port,		// valid stream port
	char		*filename,		//? backing store (or null) NYI
	int		data_size,		// count of samples to read
	int		tag,			// user data
	boolean_t	started_msg,		// send message when started
	boolean_t	completed_msg,		// send message when completed
	boolean_t	aborted_msg,		// send message when aborted
	boolean_t	paused_msg,		// send message when paused
	boolean_t	resumed_msg,		// send message when resumed
	boolean_t	overflow_msg,		// send message when overflowed
	port_t		reply_port)		// port for above messages
{
    msg_header_t *msg;
    int r, low_water, high_water, buf_size, width;
    int byte_count;

    r = get_stream_parms(stream_port,&low_water,&high_water,&buf_size,&width);
    if (r) return KERN_FAILURE;
    byte_count = ((data_size + buf_size-1) & ~(buf_size-1)) * width;

    msg = snd_stream_msg(stream_port, thread_reply(), tag);
    msg = snd_stream_record_data(msg, started_msg, completed_msg, aborted_msg, 
    				 paused_msg, resumed_msg, overflow_msg,
				 byte_count, reply_port, filename);
    /*** FIXME: 0.9 and 1.0 panic if options before region. Fixed? ***/
    msg = snd_stream_options(msg, high_water, low_water, buf_size*width);
    r = snd_send_stream_msg(msg);
    free(msg);
    return r;
}

kern_return_t snddriver_stream_start_writing (
	port_t		stream_port,		// valid stream port
	void		*data,			// pointer to samples 
	int		data_size,		// count of samples to write
	int		tag,			// user data
	boolean_t	preempt,		// play preemptively
	boolean_t	deallocate,		// deallocate data when sent
	boolean_t	started_msg,		// send message when started
	boolean_t	completed_msg,		// send message when completed
	boolean_t	aborted_msg,		// send message when aborted
	boolean_t	paused_msg,		// send message when paused
	boolean_t	resumed_msg,		// send message when resumed
	boolean_t	overflow_msg,		// send message when overflowed
	port_t		reply_port)		// port for above messages
{
    msg_header_t *msg;
    int r, low_water, high_water, buf_size, width;
    int byte_count;
    
    r = get_stream_parms(stream_port,&low_water,&high_water,&buf_size,&width);
    if (r) return KERN_FAILURE;
//    byte_count = ((data_size + buf_size-1) & ~(buf_size-1)) * width;
    byte_count = data_size * width; // no alignment restrictions for writing
    msg = snd_stream_msg(stream_port, thread_reply(), tag);
    msg = snd_stream_play_data(msg, (pointer_t)data, started_msg, 
    					completed_msg, aborted_msg, paused_msg,	
					resumed_msg, overflow_msg, preempt,
					deallocate, reply_port, byte_count);
    /*** FIXME: 0.9 panic if the options goes before the region. Fixed? ***/
    msg = snd_stream_options(msg, high_water, low_water, buf_size*width);
    r = snd_send_stream_msg(msg);
    free(msg);
    return r;
}

kern_return_t snddriver_stream_control (
	port_t		stream_port,		// valid stream port
	int		tag,			// tag to identify stream
	int		snd_control)		// await/abort/pause/resume
{
    int err;
    msg_header_t *msg;
    msg = snd_stream_msg(stream_port, thread_reply(), tag);
    msg = snd_stream_control(msg,snd_control);
    err = snd_send_stream_msg(msg);
    free(msg);
    return err;
}

kern_return_t snddriver_stream_nsamples (
	port_t		stream_port,		// valid stream port
	int		*nsamples)		// returned sample count
{
	register int r;
	union {
		snd_stream_nsamples_t	g_nsamples;
		snd_ret_samples_t	r_nsamples;
		snd_illegal_msg_t	r_ill;
		msg_header_t		header;
	} msg;
	static const snd_stream_nsamples_t M = {
		{
			/* no name */		0,
			/* msg_simple */	TRUE,
			/* msg_size */		sizeof(snd_stream_nsamples_t),
			/* msg_type */		MSG_TYPE_NORMAL,
			/* msg_remote_port */	0,
			/* msg_reply_port */	0,
			/* msg_id */		SND_MSG_STREAM_NSAMPLES
		}
	};
			
	msg.g_nsamples = M;
	msg.header.msg_remote_port = stream_port;
	msg.header.msg_local_port = thread_reply();
	
	r = msg_rpc(&msg.header, msg_rpc_options, sizeof(msg), timeout, timeout);
	if (r != KERN_SUCCESS)
		return r;
	if (msg.header.msg_id != SND_MSG_RET_SAMPLES)
		return error_ret(&msg.r_ill, SND_MSG_STREAM_NSAMPLES);
	*nsamples = msg.r_nsamples.nsamples;
	return r;
}

/*
 * Server (callout routines implemented by client -- see accesssound.c)
 */
 static kern_return_t sndreply_started(port_t port, int tag);
 static kern_return_t sndreply_completed(port_t port, int tag);
 static kern_return_t sndreply_aborted(port_t port, int tag);
 static kern_return_t sndreply_paused(port_t port, int tag);
 static kern_return_t sndreply_resumed(port_t port, int tag);
 static kern_return_t sndreply_overflow(port_t port, int tag);
 static kern_return_t sndreply_recorded_data(port_t port, int tag,
 						 pointer_t ptr, int size);
 static kern_return_t sndreply_dsp_cond_true(port_t port,u_int mask,
						u_int flags,u_int value);
 static kern_return_t sndreply_dsp_msg(port_t port, pointer_t ptr, int size);
 static kern_return_t sndreply_dsp_err(port_t port, pointer_t ptr, int size);

/*
 * The MIG-style reply_server (gets called by the sound library's
 * sndreply_server routine)
 */
static kern_return_t snddriver_reply_server(
	msg_header_t	*inmsg,			// message to handle
	msg_header_t	*outsg)			// message to return
{
    pointer_t p;
    int i, j;
    u_int u, v, w;
    switch (inmsg->msg_id) {
	case SND_MSG_STARTED:
	    i = ((snd_taged_reply_t *)inmsg)->data_tag;
	    sndreply_started(inmsg->msg_local_port, i);
	    break;
	case SND_MSG_COMPLETED:
	    i = ((snd_taged_reply_t *)inmsg)->data_tag;
	    sndreply_completed(inmsg->msg_local_port, i);
	    break;
	case SND_MSG_ABORTED:
	    i = ((snd_taged_reply_t *)inmsg)->data_tag;
	    sndreply_aborted(inmsg->msg_local_port, i);
	    break;
	case SND_MSG_PAUSED:
	    i = ((snd_taged_reply_t *)inmsg)->data_tag;
	    sndreply_paused(inmsg->msg_local_port, i);
	    break;
	case SND_MSG_RESUMED:
	    i = ((snd_taged_reply_t *)inmsg)->data_tag;
	    sndreply_resumed(inmsg->msg_local_port, i);
	    break;
	case SND_MSG_OVERFLOW:
	    i = ((snd_taged_reply_t *)inmsg)->data_tag;
	    sndreply_overflow(inmsg->msg_local_port, i);
	    break;
	case SND_MSG_RECORDED_DATA:
	    j = ((snd_recorded_data_t *)inmsg)->data_tag;
	    p = (pointer_t)((snd_recorded_data_t *)inmsg)->recorded_data;
	    i = ((snd_recorded_data_t *)inmsg)->dataType.msg_type_long_number;
	    sndreply_recorded_data(inmsg->msg_local_port, j,p,i);
	    break;
	case SND_MSG_DSP_COND_TRUE:
#if OLD_DSP_COND
	    u = v = w = 0;
#else OLD_DSP_COND
	    u = ((snd_dsp_cond_true_t *)inmsg)->mask;
	    v = ((snd_dsp_cond_true_t *)inmsg)->flags;
	    w = ((snd_dsp_cond_true_t *)inmsg)->value;
#endif OLD_DSP_COND
	    sndreply_dsp_cond_true(inmsg->msg_local_port, u,v,w);
	    break;
	case SND_MSG_RET_DSP_MSG:
	    p = (pointer_t)(&((snd_dsp_msg_t *)inmsg)->data);
	    i = ((snd_dsp_msg_t *)inmsg)->dataType.msg_type_long_number;
	    sndreply_dsp_msg(inmsg->msg_local_port, p,i);
	    break;
	case SND_MSG_RET_DSP_ERR:
	    p = (pointer_t)(&((snd_dsp_msg_t *)inmsg)->data);
	    i = ((snd_dsp_msg_t *)inmsg)->dataType.msg_type_long_number;
	    sndreply_dsp_err(inmsg->msg_local_port, p,i);
	    break;
	default:
	    return KERN_FAILURE;
    }
    return KERN_SUCCESS;
}
